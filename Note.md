此阶段的关键细节说明

原子性与一致性：

我们使用了 ON CONFLICT (entity_key)。这意味着如果前端多次保存同一个实体（比如“分润平台”），后端会自动执行更新（Update）而不是插入重复数据。

热重载：注意 refresh_fst_cache 函数。通过 RwLock 的写锁（.write().await），我们确保了在重建索引的一瞬间，查询接口会阻塞几毫秒，等新索引挂载后再恢复。这保证了**“配置即生效”**。

别名处理：

alias_names 在 Postgres 中是 TEXT[] 数组。sqlx 能够自动将其映射为 Rust 的 Vec<String>。这非常适合存储像“分润”、“平台”、“分润系统”这样的多个入口词。

串行开发的下一个目标：

现在你可以通过 Postman 或前端发送一个 JSON 到 POST /api/mapping。

下一步，我们将编写 src/api/chat.rs。这个接口将接收用户的提问（如“分润平台是什么”），调用 fst.read().await 进行匹配，并根据映射表里的物理表名、列名，拼装出最终的 SQL。

fst_engine.rs

这是我们的“语义大脑”。它会将数据库里的映射加载到内存，实现极速匹配。

mapping.rs

这一部分是整个“管理平面”的核心。它的职责是：接收前端传来的物理-语义绑定关系，保存到数据库，并触发内存中 FST 引擎的实时重构。